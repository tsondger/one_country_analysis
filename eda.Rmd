---
title: "EDA"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(warning = F,
                      message = F,
                      echo = F)

library(ggplot2)
library(reader)
library(ggthemes)
library(knitr)
library(rmarkdown)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)
library(shiny)
library(shinydashboard)
library(dashboardthemes)
library(shinyWidgets)
library(forcats)
library(readr)
library(readxl)
library(tibble)
library(kableExtra)
library(gt)

```

## Info About Files

Notes:
* Go through each of the original sales files, get all the column names for each file, recycle the file name and add to column names for each

Additional Context:


```{r}

file_list <- list.files("Data")

file_data <- tibble()

for(i in file_list){
  
  curr_file <- read_csv(file = paste0("Data\\", i))
  
  curr_file_data <- tibble(
    file_nm = i,
    col_nms = colnames(curr_file)
  )
  
  file_data <- bind_rows(file_data, curr_file_data)
  
}

```

## Gather Transaction Data

Notes:
* Append all sources together with just the relevant columns - date of event, cancellation (if applicable), product, order totals, product price
* Creates a new column that is the customer email lowercase as casing varies by order for some customers. And if the casing is different, then the emails will appear to be different. 

Additional Context:
* Very few cancellation dates
* For Boldv1 - assuming that inactive_date is the same as cancellation date
* Boldv2 doesn't have the product name
* cancelled_at is not populated for any rows in GiveOrders or Shopify

```{r}

big_comm <- read_csv(file = "Data\\BigcommerceOrders.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "(", replacement = "", x = ., fixed = T)) %>% 
  rename_all(~ gsub(pattern = ")", replacement = "", x = ., fixed = T)) %>% 
  mutate(order_date_mdy = mdy(order_date),
         order_date_dmy = dmy(order_date),
         order_date = if_else(condition = !is.na(order_date_mdy),
                              true = order_date_mdy,
                              false = order_date_dmy),
         order_id = as.character(order_id)) %>% 
  select(order_id, customer_email, order_date, order_total_inc_tax, product_details) %>% 
  rename(order_total = "order_total_inc_tax") %>% 
  mutate(file_source = "BigcommerceOrders.csv") %>% 
  rowwise() %>% 
  mutate(product_price = as.double(str_remove_all(string = str_split(string = str_split(string = product_details, 
                                                                                        pattern = ",")[[1]][length(str_split(string = product_details, 
                                                                                                                             pattern = ",")[[1]])], 
                                                                     pattern = ":", n = 2)[[1]][2], 
                                                  pattern = "[:space:]"))) %>% 
  ungroup()

bold_v1 <- read_csv(file = "Data\\Boldv1.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  select(subscription_id, customer_e_mail, 
         inactive_date,  
         subscription_date, products, total_value_of_all_products_shipped) %>% 
  mutate(subscription_date = mdy(subscription_date),
         inactive_date = mdy(inactive_date)) %>% 
  rename(order_date = "subscription_date",
         customer_email = "customer_e_mail",
         order_total = "total_value_of_all_products_shipped",
         product_details = "products",
         canceled_date = "inactive_date",
         order_id = "subscription_id") %>% 
  mutate(order_id = as.character(order_id),
         file_source = "Boldv1.csv") %>% 
  rowwise() %>% 
  mutate(product_price = 
           as.double(str_remove_all(string = str_split(string = 
                                                         str_split(string = product_details, pattern = "-")[[1]][length(str_split(string = product_details,
                                                                                                                                  pattern = "-")[[1]])], 
                                                       pattern = "x")[[1]][1], pattern = "[:space:]"))) %>% 
  ungroup()

## COME BACK - need to know if v2 of Bold has the product subscribed to

# bold_v2 <- read_csv(file = "Data\\Boldv2.csv") %>%   # Maybe skip this for now since it's missing the product??
# # tt <- bold_v2 %>%
#   rename_all(~ tolower(x = .)) %>%
#   rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>%
#   rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>%
#   rename_all(~ gsub(pattern = "/", replacement = "_", x = ., fixed = T)) %>%
#   select(customer_email, created_at,
#          # canceled_at,  # Maybe need - think about it
#          # products,  # Not finding this
#          total_value_charged)

give_orders <- read_csv(file = "Data\\GiveOrders.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  select(id, email, created_at, 
         # cancelled_at,  # May need? - Not populated
         lineitem_name, total, lineitem_price) %>% 
  mutate(created_at = date(mdy_hm(created_at)),
         id = format(id, scientific = F)) %>% 
  rename(customer_email = "email",
         order_date = "created_at",
         # canceled_date = "cancelled_at",  # See note above
         product_details = "lineitem_name",
         order_total = "total",
         order_id = "id",
         product_price = "lineitem_price") %>% 
  mutate(order_id = as.character(order_id),
         file_source = "GiveOrders.csv") %>% 
  filter(!is.na(product_price))  

mini_bc <- read_csv(file = "Data\\MiniBC.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "/", replacement = "_", x = ., fixed = T)) %>% 
  select(email_address, signup_date, product_name, charge_total, product_price) %>% 
  mutate(signup_date = date(mdy_hm(signup_date))) %>% 
  rename(customer_email = "email_address",
         order_date = "signup_date",
         order_total = "charge_total",
         product_details = "product_name") %>% 
  add_rownames(var = "order_id") %>%  # No ID found in this source, making one up from row number
  mutate(order_id = as.character(order_id),
         file_source = "MiniBC.csv")

shopify <- read_csv(file = "Data\\ShopifyOrders.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  select(id, email, created_at, 
         # cancelled_at,  # Not sure if we want to use - no values for any
         lineitem_name, total, lineitem_price) %>% 
  mutate(created_at = date(with_tz(time = ymd_hms(created_at), tzone = "America/Chicago")),
         # cancelled_at = date(with_tz(time = ymd_hms(cancelled_at), tzone = "America/Chicago"))
         id = format(id, scientific = F)) %>% 
  rename(customer_email = "email",
         order_date = "created_at",
         order_total = "total",
         product_details = "lineitem_name",
         order_id = "id",
         product_price = "lineitem_price") %>% 
  mutate(order_id = as.character(order_id),
         file_source = "ShopifyOrders.csv")

platform_data <- bind_rows(big_comm, bold_v1, give_orders, mini_bc, shopify) %>% 
  mutate(customer_email_lower = str_to_lower(string = customer_email)) %>%   # Unique customers based on this
  mutate(yr_mo_order = ymd(paste(year(order_date), month(order_date), "1", sep = "-")))

```

## Classify Product Cohorts

Notes:
* Each row was classified according to the cohort it would fall under. Later, just the first order for each customer was used to assign all orders to the cohort of the first purchase. 
* Classifying clients based on their first known purchase. Classifying them by year and month of that purchase as well as if they were an alternate entry or bonus entry lead or if they were not in these lead lists, by the product they purchased classified as either Member or One-time. Product classifications and leads were provided by Neil. 
* Further classified customers into sub groups (where applicable). For example, One-Time purchases classified further as either 5, 10 dollars,  etc

Additional Context:
* Rounding for sub-group classification applied where appropriate. For example, 24.99 and 25 were both considered 25.

```{r}

alt_entry_customers <- read_csv(file = "Data\\AlternateEntryCustomers.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  select(email, klaviyo_id, profile_created_on) %>% 
  mutate(email = str_to_lower(string = email))

bonus_entry_leads <- read_csv(file = "Data\\BonusEntryCustomers.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  select(email, profile_created_on, total_customer_lifetime_value) %>% 
  mutate(email = str_to_lower(string = email))

products_classified <- read_csv(file = "Data\\ProductsClassified.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  mutate(grp = if_else(condition = str_detect(string = classification, pattern = "Member"),
                       true = "Member",
                       false = if_else(condition = str_detect(string = classification, pattern = "One-time"),
                                       true = "One-time",
                                       false = "Other")))

platform_data_classified <- platform_data %>% 
  mutate(alt_entry = if_else(condition = customer_email_lower %in% c(alt_entry_customers$email),  # Comment when done
                             true = "Yes",
                             false = "No"),
         grp = case_when(
           customer_email_lower %in% c(alt_entry_customers$email) ~ "alt_entry",
           customer_email_lower %in% c(bonus_entry_leads$email) ~ "bonus_entry",
           product_details %in% c(products_classified$product_details[products_classified$grp == "Member"]) ~ "Member",
           product_details %in% c(products_classified$product_details[products_classified$grp == "One-time"]) ~ "One-time",
           TRUE ~ "Other"
         ),
         sub_grp = case_when(
           grp == "Member" & product_price %in% c(5.00) ~ "$5",
           grp == "Member" & product_price %in% c(10.00) ~ "$10",
           grp == "Member" & product_price %in% c(24.99, 25.00, 25.98) ~ "$25",
           grp == "One-time" & product_price %in% c(10.00) ~ "$10",
           grp == "One-time" & product_price %in% c(24.99, 25.00, 25.98) ~ "$25",
           grp == "One-time" & product_price %in% c(49.95, 49.99, 50.00, 50.96) ~ "$50",
           grp == "One-time" & product_price %in% c(99.95, 99.96, 100.00, 100.99) ~ "$100",
           grp == "alt_entry" & product_price %in% c(5.00) ~ "$5",
           grp == "alt_entry" & product_price %in% c(10.00) ~ "$10",
           grp == "alt_entry" & product_price %in% c(12.00, 12.99) ~ "$12",
           grp == "alt_entry" & product_price %in% c(15.00, 15.99) ~ "$15",
           TRUE ~ "Other"
         ),
         sales_status = if_else(condition = product_details %in% c(products_classified$product_details[products_classified$classification == "Product"]),
                                true = "Product",
                                false = "Other"))

# KEEP BELOW IN HERE TO JUSTIFY LOWERE CASING THE EMAIL - keep if I have to review this again 

# summary(as.factor(platform_data_classified$alt_entry))

# Decided based on this to lowercase the emails - know for sure I saw at least one example where to not lowercase would have caused there to be two separate
# emails that were really the same

## Delete or move later
# upcased_emails <- platform_data %>% group_by(customer_email) %>% tally() %>% arrange(desc(n))  # All
# 
# lowcase_emails <- platform_data %>% mutate(customer_email = str_to_lower(string = customer_email)) %>%  # lower cased
#   group_by(customer_email) %>% tally() %>% arrange(desc(n)) %>% ungroup()
# 
# tt <- upcased_emails %>% 
#   select(customer_email) %>%
#   mutate(not_in_lower = if_else(condition = customer_email %in% c(lowcase_emails$customer_email),
#                                 true = "Kept",
#                                 false = "Lost"),
#          customer_email_lower = str_to_lower(string = customer_email))
# mutate(customer_email_lower = str_to_lower(string = customer_email),
# case_diff = if_else(condition = customer_email != customer_email_lower,
# true = "Different",
# false = "Same"))

# xx <- tt %>% filter(not_in_lower == "Lost")

# tt <- products_classified %>% group_by(grp, classification) %>% tally()

```

## Classify All Purchases According to Customer First Transaction

Notes:
* Identified the first purchase for each customer and classified all subsequent orders to that cohort.
* Identified when the customer is "lost" - If they had a cancellation date, and no orders beyond that cancellation date, considered them lost. 

Additional Context:


```{r}

## NEXT ##



platform_data_cohorts <- platform_data_classified %>% 
  # filter(customer_email %in% c("Kylepyeoman@gmail.com", "trendaadkins@yahoo.com", "hopeangeltaylor@icloud.com")) %>% ## For testing - comment out
  arrange(customer_email, order_date) %>% 
  group_by(customer_email) %>% 
  mutate(customer_transaction_number = row_number()) %>% 
  ungroup() %>% 
  mutate(cohort = if_else(condition = customer_transaction_number == 1,
                          true = paste0(grp, " ", month(order_date, label = T), "/", year(order_date)),
                          false = ""),
         cohort = na_if(cohort, ""),
         first_order_date = if_else(condition = customer_transaction_number == 1,
                                    true = order_date,
                                    false = ymd("2099-1-1")),
         first_order_date = na_if(first_order_date, ymd("2099-1-1"))) %>% 
  fill(cohort, .direction = "down") %>% 
  fill(first_order_date, .direction = "down") %>% 
  group_by(customer_email) %>% 
  mutate(total_transactions = max(customer_transaction_number),
         max_cancel_date = max(canceled_date, na.rm = T)) %>% 
  fill(max_cancel_date, .direction = "down") %>% 
  ungroup() %>% 
  mutate(customer_lost = if_else(condition = !is.na(max_cancel_date) & 
                                   customer_transaction_number == total_transactions &
                                   order_date < max_cancel_date,
                                 # true = 1,
                                 # false = 0))
                                 true = "Lost",
                                 false = "Retained")) %>% 
  rowwise() %>% 
  mutate(months_since_first_purchase = interval(first_order_date, order_date) %/% months(1))

```



```{r}

# Might want to write platform data to csv and then read that in

write_csv(platform_data_cohorts,
          path = "Output Data\\cohorts_classified.csv")

```

# Can move this as it was just exploratory. - Not releveant to future analysis

## Getting Product Lists to One-Country 

```{r}

# Next:
# Address questions above
# See about cancel dates and how we may define them where not present
# Classify each product according to the classification scheme

# Classify products according to specs

unique_products <- platform_data %>% 
  # distinct(products) %>% 
  group_by(product_details, product_price) %>% 
  tally() %>% 
  arrange(desc(n))

```

```{r}

# Classifying alternate entries

product_name_has_free <- unique_products %>% 
  filter(str_detect(string = product_details, pattern = "free"))

```

```{r eval=FALSE}

# Writing out products for classification

write_csv(unique_products,
          path = "Exploratory Output\\Unique Products and Prices.csv")

write_csv(product_name_has_free,
          path = "Exploratory Output\\Products with Free in Product Names.csv")

```


```{r}

# Testing where product price is not there

# All good now

sum(is.na(platform_data$canceled_date))

sum(!is.na(platform_data$canceled_date))

sum(!is.na(platform_data$canceled_date))/nrow(platform_data) * 100

tt <- platform_data %>% filter(is.na(canceled_date))

sort(unique(tt$file_source))

```


























