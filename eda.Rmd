---
title: "EDA"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(warning = F,
                      message = F,
                      echo = F)

library(ggplot2)
library(reader)
library(ggthemes)
library(knitr)
library(rmarkdown)
library(dplyr)
library(tidyr)
library(lubridate)
library(stringr)
library(shiny)
library(shinydashboard)
library(dashboardthemes)
library(shinyWidgets)
library(forcats)
library(readr)
library(readxl)
library(tibble)
library(kableExtra)
library(gt)

## Next Steps ##

# Provide a way to look at cohort LTV in $/customer or total customers in addition to or instead of just total $ in orders (pbi calc measure)
# When I get to churn, expect to see around 8%/month to sanity check the numbers shown (sanity check - add measure for churn)

# See why months since first purchase is blank ever - it's bold v2 - see why
# See why degredation of overall spend is dropping off so much - try looking at a few. Should be much less steep. Try a few individual ppl as well. 

```

## Info About Files

Notes:
* Go through each of the original sales files, get all the column names for each file, recycle the file name and add to column names for each

Additional Context:


```{r}

file_list <- list.files("Data")

file_data <- tibble()

for(i in file_list){
  
  curr_file <- read_csv(file = paste0("Data\\", i))
  
  curr_file_data <- tibble(
    file_nm = i,
    col_nms = colnames(curr_file)
  )
  
  file_data <- bind_rows(file_data, curr_file_data)
  
}

```

## Gather Transaction Data

Notes:
* Append all sources together with just the relevant columns - date of event, cancellation (if applicable), product, order totals, product price
* Creates a new column that is the customer email lowercase as casing varies by order for some customers. And if the casing is different, then the emails will appear to be different. 

Additional Context:
* Very few cancellation dates
* For Boldv1 - assuming that inactive_date is the same as cancellation date
* Boldv2 doesn't have the product name
* cancelled_at is not populated for any rows in GiveOrders or Shopify

```{r}

big_comm <- read_csv(file = "Data\\2021-01-07-bc-orders.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "(", replacement = "", x = ., fixed = T)) %>% 
  rename_all(~ gsub(pattern = ")", replacement = "", x = ., fixed = T)) %>% 
  mutate(
    # order_date_mdy = mdy(order_date),
         order_date = dmy(order_date),  # Treal ALL as dmy -- Testing
         # order_date = if_else(condition = !is.na(order_date_mdy),
         #                      true = order_date_mdy,
         #                      false = order_date_dmy),
         order_id = as.character(order_id)
    ) %>% 
  select(order_id, customer_email, order_date, order_total_inc_tax, product_details) %>% 
  rename(order_total = "order_total_inc_tax") %>% 
  mutate(file_source = "BigcommerceOrders.csv") %>% 
  rowwise() %>% 
  mutate(product_price = as.double(str_remove_all(string = str_split(string = str_split(string = product_details, 
                                                                                        pattern = ",")[[1]][length(str_split(string = product_details, 
                                                                                                                             pattern = ",")[[1]])], 
                                                                     pattern = ":", n = 2)[[1]][2], 
                                                  pattern = "[:space:]"))) %>% 
  ungroup() %>% 
  mutate(product_price = case_when(
    str_detect(string = product_details, pattern = "Product ID: 3805|Product ID: 5100|Product ID: 4295|Product ID: 3798|Product ID: 3805") ~ 10,
    str_detect(string = product_details, pattern = "Product ID: 3797") ~ 5,
    str_detect(string = product_details, pattern = "Product ID: 3799") ~ 15,
    str_detect(string = product_details, pattern = "Product ID: 3966") ~ 50,
    str_detect(string = product_details, pattern = "Product ID: 3800|Product ID: 5104") ~ 25,
    TRUE ~ product_price
  ))

# bold_v1 <- read_csv(file = "Data\\Boldv1.csv") %>% 
#   rename_all(~ tolower(x = .)) %>%
#   rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
#   rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
#   select(subscription_id, customer_e_mail, 
#          inactive_date,  
#          subscription_date, products, total_value_of_all_products_shipped) %>% 
#   mutate(subscription_date = mdy(subscription_date),
#          inactive_date = mdy(inactive_date)) %>% 
#   rename(order_date = "subscription_date",
#          customer_email = "customer_e_mail",
#          order_total = "total_value_of_all_products_shipped",
#          product_details = "products",
#          canceled_date = "inactive_date",
#          order_id = "subscription_id") %>% 
#   mutate(order_id = as.character(order_id),
#          file_source = "Boldv1.csv") %>% 
#   rowwise() %>% 
#   mutate(product_price = 
#            as.double(str_remove_all(string = str_split(string = 
#                                                          str_split(string = product_details, pattern = "-")[[1]][length(str_split(string = product_details,
#                                                                                                                                   pattern = "-")[[1]])], 
#                                                        pattern = "x")[[1]][1], pattern = "[:space:]"))) %>% 
#   ungroup()

## COME BACK - need to know if v2 of Bold has the product subscribed to

# bold_v2 <- read_csv(file = "Data\\Boldv2.csv") %>%   # Maybe skip this for now since it's missing the product??
# # tt <- bold_v2 %>%
#   rename_all(~ tolower(x = .)) %>%
#   rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>%
#   rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>%
#   rename_all(~ gsub(pattern = "/", replacement = "_", x = ., fixed = T)) %>%
#   mutate(products = "None in file") %>% 
#   select(subscription_id, customer_email, created_at,
#          canceled_at,  # Maybe need - think about it
#          products,  # Not finding this
#          total_value_charged) %>% 
#   mutate(created_at = ymd_hms(created_at),
#          created_at = date(created_at),
#          canceled_at = ymd_hms(canceled_at),
#          canceled_at = date(canceled_at)) %>% 
#   rename(order_date = "created_at",
#          customer_email = "customer_email",
#          order_total = "total_value_charged",
#          product_details = "products",
#          canceled_date = "canceled_at",
#          order_id = "subscription_id") %>%
#   mutate(order_id = as.character(order_id),
#          file_source = "Boldv2.csv") %>% 
#   mutate(product_price = 10)

give_orders <- read_csv(file = "Data\\2022-01-07_Give.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  select(id, email, created_at, 
         # cancelled_at,  # May need? - Not populated
         lineitem_name, total, lineitem_price) %>% 
  mutate(
    # created_at = date(mdy_hm(created_at)),
    created_at = ymd(str_sub(string = created_at, start = 1, end = 10)),
    id = format(id, scientific = F)) %>% 
  rename(customer_email = "email",
         order_date = "created_at",
         # canceled_date = "cancelled_at",  # See note above
         product_details = "lineitem_name",
         order_total = "total",
         order_id = "id",
         product_price = "lineitem_price") %>% 
  mutate(order_id = as.character(order_id),
         file_source = "GiveOrders.csv") %>% 
  filter(!is.na(product_price))  

# mini_bc <- read_csv(file = "Data\\MiniBC.csv") %>% 
#   rename_all(~ tolower(x = .)) %>%
#   rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
#   rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
#   rename_all(~ gsub(pattern = "/", replacement = "_", x = ., fixed = T)) %>% 
#   select(email_address, signup_date, product_name, charge_total, product_price) %>% 
#   mutate(signup_date = date(mdy_hm(signup_date))) %>% 
#   rename(customer_email = "email_address",
#          order_date = "signup_date",
#          order_total = "charge_total",
#          product_details = "product_name") %>% 
#   add_rownames(var = "order_id") %>%  # No ID found in this source, making one up from row number
#   mutate(order_id = as.character(order_id),
#          file_source = "MiniBC.csv")

shopify <- read_csv(file = "Data\\2022-01-07_Shopify.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  select(id, email, created_at, 
         # cancelled_at,  # Not sure if we want to use - no values for any
         lineitem_name, total, lineitem_price) %>% 
  mutate(created_at = date(with_tz(time = ymd_hms(created_at), tzone = "America/Chicago")),
         # cancelled_at = date(with_tz(time = ymd_hms(cancelled_at), tzone = "America/Chicago"))
         id = format(id, scientific = F)) %>% 
  rename(customer_email = "email",
         order_date = "created_at",
         order_total = "total",
         product_details = "lineitem_name",
         order_id = "id",
         product_price = "lineitem_price") %>% 
  mutate(order_id = as.character(order_id),
         file_source = "ShopifyOrders.csv")

platform_data <- bind_rows(big_comm, 
                           # bold_v1, bold_v2, 
                           give_orders, 
                           # mini_bc, 
                           shopify) %>% 
  mutate(customer_email_lower = str_to_lower(string = customer_email)) %>%   # Unique customers based on this
  mutate(yr_mo_order = ymd(paste(year(order_date), month(order_date), "1", sep = "-")))

```

## Classify Product Cohorts

Notes:
* Each row was classified according to the cohort it would fall under. Later, just the first order for each customer was used to assign all orders to the cohort of the first purchase. 
* Classifying clients based on their first known purchase. Classifying them by year and month of that purchase as well as if they were an alternate entry or bonus entry lead or if they were not in these lead lists, by the product they purchased classified as either Member or One-time. Product classifications and leads were provided by Neil. 
* Further classified customers into sub groups (where applicable). For example, One-Time purchases classified further as either 5, 10 dollars,  etc

Additional Context:
* Rounding for sub-group classification applied where appropriate. For example, 24.99 and 25 were both considered 25.

```{r}

alt_entry_customers <- read_csv(file = "Data\\AlternateEntryCustomers.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  select(email, klaviyo_id, profile_created_on) %>% 
  mutate(email = str_to_lower(string = email))

bonus_entry_leads <- read_csv(file = "Data\\BonusEntryCustomers.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  select(email, profile_created_on, total_customer_lifetime_value) %>% 
  mutate(email = str_to_lower(string = email))

products_classified <- read_csv(file = "Data\\ProductsClassified.csv") %>% 
  rename_all(~ tolower(x = .)) %>%
  rename_all(~ gsub(pattern = " ", replacement = "_", x = .)) %>% 
  rename_all(~ gsub(pattern = "-", replacement = "_", x = .)) %>% 
  mutate(grp = case_when(
    str_detect(string = classification, pattern = "Member") ~ "Member",
    str_detect(string = classification, pattern = "bonus") ~ "Bonus",
    str_detect(string = classification, pattern = "One-time") ~ "One-time",
    TRUE ~ "Other")) %>% 
  mutate(grp = case_when(
    str_detect(string = product_details, pattern = "Product ID: 3805|Product ID: 5100|Product ID: 4295|Product ID: 3798|Product ID: 3797|Product ID: 3799|Product ID: 3966|Product ID: 3800|Product ID: 5104") ~ "Member",
    TRUE ~ grp
  ))
  # mutate(grp = if_else(condition = str_detect(string = classification, pattern = "Member"),
  #                      true = "Member",
  #                      false = if_else(condition = str_detect(string = classification, pattern = "One-time"),
  #                                      true = "One-time",
  #                                      false = "Other")))

# This is what I need to use to exclude all bonus entry orders from

platform_data_classified <- platform_data %>% 
  filter(!(product_details %in% c(products_classified$product_details[products_classified$grp == "Bonus"]))) %>%  # New - excluding bonus products, excludes ALOT
  mutate(alt_entry = if_else(condition = customer_email_lower %in% c(alt_entry_customers$email),  # Comment when done
                             true = "Yes",
                             false = "No"),
         customer_entry = case_when(
           customer_email_lower %in% c(alt_entry_customers$email) ~ "alt_entry",
           customer_email_lower %in% c(bonus_entry_leads$email) ~ "bonus_entry",
           TRUE ~ "Other"
         ),
         
         grp = case_when(
           product_details %in% c(products_classified$product_details[products_classified$grp == "Member"]) ~ "Member"
           # | file_source == "Boldv2.csv" ~ "Member"  # No longer needed
           ,
           product_details %in% c(products_classified$product_details[products_classified$grp == "One-time"]) ~ "One-time",
           TRUE ~ "Other"
         ),
         sub_grp = case_when(
           grp == "Member" & product_price %in% c(5.00) ~ "$5",
           (grp == "Member" & product_price %in% c(10.00)) | file_source == "Boldv2.csv" ~ "$10",
           grp == "Member" & product_price %in% c(24.99, 25.00, 25.98) ~ "$25",
           grp == "One-time" & product_price %in% c(10.00) ~ "$10",
           grp == "One-time" & product_price %in% c(24.99, 25.00, 25.98) ~ "$25",
           grp == "One-time" & product_price %in% c(49.95, 49.99, 50.00, 50.96) ~ "$50",
           grp == "One-time" & product_price %in% c(99.95, 99.96, 100.00, 100.99) ~ "$100",
           grp == "alt_entry" & product_price %in% c(5.00) ~ "$5",
           grp == "alt_entry" & product_price %in% c(10.00) ~ "$10",
           grp == "alt_entry" & product_price %in% c(12.00, 12.99) ~ "$12",
           grp == "alt_entry" & product_price %in% c(15.00, 15.99) ~ "$15",
           TRUE ~ "Other"
         ),
         sales_status = if_else(condition = product_details %in% c(products_classified$product_details[products_classified$classification == "Product"]),
                                true = "Product",
                                false = "Other"))

# KEEP BELOW IN HERE TO JUSTIFY LOWERE CASING THE EMAIL - keep if I have to review this again 

# summary(as.factor(platform_data_classified$alt_entry))

# Decided based on this to lowercase the emails - know for sure I saw at least one example where to not lowercase would have caused there to be two separate
# emails that were really the same

## Delete or move later
# upcased_emails <- platform_data %>% group_by(customer_email) %>% tally() %>% arrange(desc(n))  # All
# 
# lowcase_emails <- platform_data %>% mutate(customer_email = str_to_lower(string = customer_email)) %>%  # lower cased
#   group_by(customer_email) %>% tally() %>% arrange(desc(n)) %>% ungroup()
# 
# tt <- upcased_emails %>% 
#   select(customer_email) %>%
#   mutate(not_in_lower = if_else(condition = customer_email %in% c(lowcase_emails$customer_email),
#                                 true = "Kept",
#                                 false = "Lost"),
#          customer_email_lower = str_to_lower(string = customer_email))
# mutate(customer_email_lower = str_to_lower(string = customer_email),
# case_diff = if_else(condition = customer_email != customer_email_lower,
# true = "Different",
# false = "Same"))

# xx <- tt %>% filter(not_in_lower == "Lost")

# tt <- products_classified %>% group_by(grp, classification) %>% tally()

```

## Classify All Purchases According to Customer First Transaction

Notes:
* Identified the first purchase for each customer and classified all subsequent orders to that cohort.
* Identified when the customer is "lost" - If they had a cancellation date, and no orders beyond that cancellation date, considered them lost. 

Additional Context:


```{r}

# NEED TO RUN ALL - then try in Power BI

platform_data_cohorts <- platform_data_classified %>%
# yy <- platform_data_classified %>%   # For testing
  
  # Don't think I need this part  
  filter(file_source %in% c("BigcommerceOrders.csv" , "GiveOrders.csv" , "ShopifyOrders.csv")) %>%  # Testing and excluding subscription platforms, may not work well

  # filter(customer_email_lower %in% c(
  #   "a.e.flynn@hotmail.com",
  #   "aaronj.garnica@gmail.com"
  #   )) %>% ## For general testing - comment out
  arrange(customer_email_lower, order_date) %>% 
  group_by(customer_email_lower) %>% 
  mutate(customer_transaction_number_classify = if_else(condition = grp %in% c("Member", "One-time"), 
                                                        true = row_number(),
                                                        false = as.integer(0)),
         customer_transaction_number_classify = na_if(customer_transaction_number_classify, 0),
         customer_transaction_number = row_number(),
         
         customer_sub_group_transaction_number_classify = if_else(condition = grp == "Member",
                                                                  true = row_number(),
                                                                  false = as.integer(0)),
         customer_sub_group_transaction_number_classify = na_if(customer_sub_group_transaction_number_classify, 0),
         min_customer_sub_group_transaction_number_classify = min(customer_sub_group_transaction_number_classify, na.rm = T),
         
         first_customer_order = min(customer_transaction_number_classify, na.rm = T),
         min_transaction_date = min(order_date, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(first_order_date = if_else(condition = customer_transaction_number_classify == first_customer_order,
                                    true = order_date,
                                    false = ymd("2099-1-1")),
         first_order_date = na_if(first_order_date, ymd("2099-1-1")),
         cohort_grp = if_else(condition = customer_transaction_number_classify == first_customer_order,
                              true = grp,
                              false = ""),
         cohort_grp = na_if(cohort_grp, ""),
         cohort_sub_grp = if_else(condition = customer_transaction_number_classify == first_customer_order,
                                  true = sub_grp,
                                  false = ""),
         cohort_sub_grp = na_if(cohort_sub_grp, "")) %>% 
  group_by(customer_email_lower, order_date) %>%
  # Think this could be an issue if I'm missing the order_date - think it's the any()
  mutate(cohort_grp = if_else(condition = order_date == min_transaction_date & any(grp == "Member"),
                              true = "Member",
                              false = cohort_grp),
         # NEW
         cohort_sub_grp = if_else(condition = any(grp == "Member") &
                                    customer_sub_group_transaction_number_classify == min_customer_sub_group_transaction_number_classify &
                                    !is.infinite(min_customer_sub_group_transaction_number_classify)
                                  & order_date == min_transaction_date  # NEW
                                  ,
                                  true = sub_grp,
                                  false = cohort_sub_grp)) %>%
  ungroup() %>%
         # cohort_sub_grp = case_when(
         #   order_date == min_transaction_date & any(grp == "Member") & any(sub_grp == "$10") ~ "$10",
         #   order_date == min_transaction_date & any(grp == "Member") & any(sub_grp == "$100") ~ "$100",
         #   order_date == min_transaction_date & any(grp == "Member") & any(sub_grp == "$5") ~ "$5",
         #   order_date == min_transaction_date & any(grp == "Member") & any(sub_grp == "$25") ~ "$25",
         #   
         #   order_date == min_transaction_date & any(grp == "Member") & any(sub_grp == "$50") ~ "$50",
         #   TRUE ~ cohort_sub_grp)) %>%
         # cohort_sub_grp = case_when(
         #   order_date == min_transaction_date & any(grp == "Member") & any(sub_grp == "$10") ~ "$10",
         #   order_date == min_transaction_date & any(grp == "Member") & any(sub_grp == "$100") ~ "$100",
         #   order_date == min_transaction_date & any(grp == "Member") & any(sub_grp == "$25") ~ "$25",
         #   order_date == min_transaction_date & any(grp == "Member") & any(sub_grp == "$5") ~ "$5",
         #   order_date == min_transaction_date & any(grp == "Member") & any(sub_grp == "$50") ~ "$50",
         #   TRUE ~ cohort_sub_grp)) %>%
  # ungroup() %>%  # Moved
group_by(customer_email_lower) %>%   
  fill(first_order_date, .direction = "down") %>% 
  fill(cohort_grp, .direction = "down") %>% 
  fill(cohort_sub_grp, .direction = "down") %>% 
  fill(first_order_date, .direction = "up") %>% 
  fill(cohort_grp, .direction = "up") %>% 
  fill(cohort_sub_grp, .direction = "up") %>% 
  ungroup() %>% # Moved here
  mutate(cohort = if_else(condition = customer_transaction_number_classify == first_customer_order, 
                          true = paste0(cohort_grp, " ", month(order_date, label = T), "/", year(order_date)),
                          false = ""),
         cohort = na_if(cohort, "")) %>% 
  group_by(customer_email_lower) %>%  # Added
  fill(cohort, .direction = "down") %>% 
  fill(cohort, .direction = "up") %>% 
  # group_by(customer_email_lower) %>% 
  mutate(total_transactions = max(customer_transaction_number),
         # max_cancel_date = max(canceled_date, na.rm = T),
         max_transaction_date = max(order_date, na.rm = T),
         yr_mo_first_order = ymd(paste(year(first_order_date), month(first_order_date), "1", sep = "-"))) %>% 
  # fill(max_cancel_date, .direction = "down") %>% 
  fill(max_transaction_date, .direction = "down") %>% 
  ungroup() %>% 
  mutate(transaction_within_past_60_days = if_else(condition = max_transaction_date > (Sys.Date() - 60),
                                                   true = "Yes",
                                                   false = "No"),
         customer_lost = if_else(condition = 
                                   # (!is.na(max_cancel_date) & customer_transaction_number == total_transactions & order_date < max_cancel_date) |
                                   # (!is.na(max_cancel_date) & 
                                      customer_transaction_number == total_transactions & transaction_within_past_60_days == "No"
                                 # )
                                 ,
                                 true = "Lost",
                                 false = "Retained")) %>% 
  rowwise() %>% 
  mutate(months_since_first_purchase = interval(first_order_date, order_date) %/% months(1)) %>% 
  ungroup() %>% 
  filter(months_since_first_purchase >= 0) %>% 
  filter(!(cohort_grp == "Member" & str_detect(string = cohort, pattern = "One-time")))  # NEW

write_csv(platform_data_cohorts,
          path = "Output Data\\cohorts_classified.csv")

```



```{r}

# Might want to write platform data to csv and then read that in

# write_csv(platform_data_cohorts,
#           path = "Output Data\\cohorts_classified.csv")

```

## Checking Data

```{r eval=FALSE}

tt <- read_csv(file = "Output Data\\cohorts_classified.csv") %>%
  # filter(!(cohort_grp == "Member" & str_detect(string = cohort, pattern = "One-time")))
  filter(customer_email_lower == "a.e.flynn@hotmail.com")

grp_breakdown <- tt %>% 
  group_by(cohort_grp, cohort_sub_grp) %>% 
  tally()

cohort_breakdown <- tt %>% 
  group_by(cohort_grp, cohort) %>% 
  tally()

xx <- tt %>% 
  filter(cohort_grp == "Member" & str_detect(string = cohort, pattern = "One-time"))

zz <- tt %>% filter(customer_email == "jennyequirk@gmail.com")

## These are the unique customers that have a member and one-time purchase on the same date - mixed carts, lots. HERE 

zz <- tt %>%
  # slice(1:10000) %>% 
  group_by(customer_email, grp, order_date) %>% 
  tally() %>% 
  spread(key = grp, value = n) %>% 
  filter(!is.na(Member) & !is.na(`One-time`)) %>% 
  distinct(customer_email)

```


# Can move this as it was just exploratory. - Not releveant to future analysis

## Getting Product Lists to One-Country 

```{r}

# Next:
# Address questions above
# See about cancel dates and how we may define them where not present
# Classify each product according to the classification scheme

# Classify products according to specs

unique_products <- platform_data %>% 
  # distinct(products) %>% 
  group_by(product_details, product_price) %>% 
  tally() %>% 
  arrange(desc(n))

```

```{r}

# Classifying alternate entries

product_name_has_free <- unique_products %>% 
  filter(str_detect(string = product_details, pattern = "free"))

```

```{r eval=FALSE}

# Writing out products for classification

write_csv(unique_products,
          path = "Exploratory Output\\Unique Products and Prices.csv")

write_csv(product_name_has_free,
          path = "Exploratory Output\\Products with Free in Product Names.csv")

```


```{r}

# Testing where product price is not there

# All good now

sum(is.na(platform_data$canceled_date))

sum(!is.na(platform_data$canceled_date))

sum(!is.na(platform_data$canceled_date))/nrow(platform_data) * 100

tt <- platform_data %>% filter(is.na(canceled_date))

sort(unique(tt$file_source))

```


























